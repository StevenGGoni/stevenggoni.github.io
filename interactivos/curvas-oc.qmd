---
title: "Curvas OC - Muestreo por atributos"
---

## Instrucciones de uso

Este visualizador permite explorar las curvas características de planes de muestreo por atributos. Al seleccionar una distribución (Binomial, Poisson o Hipergeométrica), puede ajustar los parámetros del plan y observar cómo cambian tres curvas asociadas:

* La curva OC (*Operating Characteristic*) muestra la probabilidad de aceptar un lote en función de la fracción defectuosa. Ilustra el equilibrio entre el riesgo del productor (α) y el riesgo del consumidor (β).

* La curva AOQ (*Average Outgoing Quality*) muestra la fracción defectuosa esperada después de inspección, útil para evaluar la calidad promedio de salida.

* La curva ITP (*Inspección Total Promedio*) presenta la relación entre la calidad del material entrante y el número de elementos que se deben inspeccionar, suponiendo que los lotes rechazados se inspeccionarán en un 100% y se realizará una inspección de rectificación de los elementos defectuosos. 

Ajuste los parámetros del plan: tamaño de muestra (*n*), nivel de aceptación (*c*), tamaño del lote (*N*) y los riesgos *α* y *β*. Cada modificación actualiza automáticamente las curvas. También se marcan los puntos AQL (*Acceptable Quality Level*) y LQL (*Lot Tolerance Percent Defective*) cuando corresponden, lo que facilita interpretar las regiones típicas de desempeño del plan.

Observe cómo cada distribución induce una forma distinta de la curva OC:la Binomial modela defectos independientes en muestras moderadas; la Poisson simplifica el caso de eventos raros; y la Hipergeométrica considera inspección sin reemplazo, capturando la finitud del lote.

```{=html}
<div class="widget-box">

<head>
  <meta charset="utf-8">
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jstat/1.9.4/jstat.min.js"></script>
  <style>
    label { font-weight: bold; }
      #container {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-top: 1em;
        gap: 20px;
        width: 100%;
        box-sizing: border-box;
      }
      
      #plot_oc {
        width: 95%;
        height: 350px;        /* alto razonable para desktop */
        max-width: 1000px;    /* no crecer infinito */
      }
      
      .plot-row {
        display: flex;
        justify-content: center;
        gap: 20px;
        flex-wrap: wrap;      /* ya permite stacking */
        width: 95%;
        max-width: 1000px;
      }
      
      .small-plot {
        flex: 1 1 300px;      /* se acomoda fluido */
        height: 300px;
      }
      
      @media (max-width: 700px) {
        #plot_oc {
          height: 300px;
        }
        .small-plot {
          height: 260px;
        }
      }
    #controls {
      display: grid;
      grid-template-columns: repeat(3, 1fr); /* tres columnas */
      gap: 16px 24px; /* espacio vertical/horizontal */
      max-width: 900px;
      margin: 1em auto;
      }
      
      
      .input-group {
      display: flex;
      flex-direction: column;
      font-size: 0.95rem;
      }
      
      
      .input-group label {
      font-weight: 600;
      margin-bottom: 4px;
      }
      
      
      .input-group input {
      width: 100%;
      box-sizing: border-box;
      }
      
      @media (max-width: 700px) {
        #controls {
          grid-template-columns: repeat(2, 1fr); /* dos columnas */
        }
      }
      
      @media (max-width: 450px) {
        #controls {
          grid-template-columns: 1fr;            /* una sola columna */
        }
      }
  </style>
</head>
<body>

  <div style="max-width: 900px; margin: 0 auto;">

  <label>Seleccione una distribución:</label>
  <select id="distribution" onchange="renderControls(); updatePlots();">
    <option value="binomial">Binomial</option>
    <option value="hypergeometric">Hipergeométrica</option>
    <option value="poisson">Poisson</option>
    <option value="oc_only">Comparar (solo OC)</option>
  </select>

  <div id="controls"></div>

  <div id="container">
    <div id="plot_oc"></div>
      <div id="plots-extra" class="plot-row">
        <div id="plot_aoq" class="small-plot"></div>
        <div id="plot_itp" class="small-plot"></div>
      </div>
  </div>

  <script>
    const COLOR_SINGLE = "#331114";
    const COLOR_SECOND = "#9BA1AB";
    const COLOR_THIRD = "#B5B7C0"; // un gris suave para ITP
    function controlInput(id, label, min, max, value, step = 1) {
      return `
        <div class="input-group">
          <label for="${id}">${label}:</label>
          <input type="number" id="${id}" min="${min}" max="${max}" value="${value}" step="${step}"
            onchange="updatePlots();" style="width: 100px;">
        </div>
      `;
    }

    function renderControls() {
      const controls = document.getElementById("controls");
      let html = "";

      html += controlInput("n", "Tamaño de muestra (n)", 1, 1000, 50);
      html += controlInput("c", "Nivel de aceptación (c)", 0, 100, 2);
      html += controlInput("N", "Tamaño del lote (N)", 1, 1000000, 10000);
      html += controlInput("alpha", "α (riesgo del productor)", 0.001, 0.999, 0.05, 0.001);
      html += controlInput("beta", "β (riesgo del consumidor)", 0.001, 0.999, 0.10, 0.001);

      controls.innerHTML = html;
    }

    function updatePlots() {
      const dist = document.getElementById("distribution").value;
      const n = parseInt(document.getElementById("n").value);
      const c = parseInt(document.getElementById("c").value);
      const N = parseInt(document.getElementById("N").value);
      const alpha = parseFloat(document.getElementById("alpha").value);
      const beta = parseFloat(document.getElementById("beta").value);
      
      const x = [], Pa_y = [], AOQ_y = [], ITP_y = [];
      const step = 0.00001;
      const max_p = (dist === "hypergeometric") ? 1 : 0.2;
      
      // Manejo estético de contenedores según modo
        const plotsExtra = document.getElementById("plots-extra");
        const plotOC = document.getElementById("plot_oc");
        
        if (dist === "oc_only") {
          // Modo comparación solo OC: ocultar AOQ e ITP
          plotsExtra.style.display = "none";
        
          // Hacer que OC ocupe todo el ancho
          plotOC.style.width = "95%";  
          plotOC.style.height = "450px"; 
        } else {
          // Modo estándar: mostrar AOQ e ITP
          plotsExtra.style.display = "flex";
        
          // Restaurar tamaño original de OC
          plotOC.style.width = "95%";
          plotOC.style.height = "350px";
        }

      if (dist === "oc_only") {
        const curves = [
          { name:"Binomial", color:"#331114", dist:"binomial", width: 3, dash: "solid" },
          { name:"Poisson", color:"#9BA1AB", dist:"poisson", width: 3, dash: "dash" },
          { name:"Hipergeométrica", color:"#B94F4F", dist:"hypergeometric", width: 3, dash: "dot" }
        ];
      
        let plotData = [];
      
        for (let curve of curves) {
          const x = [], y = [];
          for (let p = 0; p <= max_p; p += step) {
            let Pa = 0;
      
            if (curve.dist === "binomial") {
              for (let k = 0; k <= c; k++) Pa += jStat.binomial.pdf(k, n, p);
            }
      
            if (curve.dist === "poisson") {
              const lambda = n * p;
              for (let k = 0; k <= c; k++) Pa += jStat.poisson.pdf(k, lambda);
            }
      
            if (curve.dist === "hypergeometric") {
              const D = Math.round(p * N);
              for (let k = 0; k <= c; k++) Pa += jStat.hypgeom.pdf(k, N, D, n);
            }
      
            x.push(p);
            y.push(Pa);
          }
      
          plotData.push({
            x, y,
            type:"scatter",
            mode:"lines",
            line:{ color:curve.color, width: curve.width, dash: curve.dash },
            name: curve.name
          });
        }
      
        Plotly.purge("plot_oc");
        Plotly.newPlot("plot_oc", plotData, {
          title:{ text:"Curvas OC Comparadas", font: { family: "Crimson Pro" }},
          xaxis:{ title:"Fracción defectuosa (p)", 
            titlefont: { family: "Aller" },
            tickfont: { family: "Aller" } },
          yaxis:{ title:"Probabilidad de aceptación",
            titlefont: { family: "Aller" },
            tickfont: { family: "Aller" }},
          legend: { font: { family: "Aller" } },
          paper_bgcolor:'rgba(0,0,0,0)',
          plot_bgcolor:'rgba(0,0,0,0)',
        });
      
        // Se limpian AOQ e ITP porque en este modo no van
        Plotly.purge("plot_aoq");
        Plotly.purge("plot_itp");
        return;
      }

      for (let p = 0.000; p <= max_p; p += step) {
        let Pa = 0;

        if (dist === "binomial") {
          for (let k = 0; k <= c; k++) {
            Pa += jStat.binomial.pdf(k, n, p);
          }
        } else if (dist === "poisson") {
          const lambda = n * p;
          for (let k = 0; k <= c; k++) {
            Pa += jStat.poisson.pdf(k, lambda);
          }
        } else if (dist === "hypergeometric") {
          const D = Math.round(p * N);
          Pa = 0;
          for (let k = 0; k <= c; k++) {
            Pa += jStat.hypgeom.pdf(k, N, D, n);
          }
        }

        if (Pa >= 0.005) {
          const AOQ = Pa * p;
          const ITP = n + (1 - Pa) * (N - n);

          x.push(p);
          Pa_y.push(Pa);
          AOQ_y.push(AOQ);
          ITP_y.push(ITP);
        }
      }

      let AQL = null, LQL = null;
      for (let i = 0; i < Pa_y.length; i++) {
        if (AQL === null && Math.abs(Pa_y[i] - (1 - alpha)) < 0.001) AQL = x[i];
        if (LQL === null && Math.abs(Pa_y[i] - beta) < 0.001) LQL = x[i];
      }

      const titleMap = {
        binomial: "Binomial",
        poisson: "Poisson",
        hypergeometric: "Hipergeométrica"
      };

      const oc_traces = [{
        x: x,
        y: Pa_y,
        type: "scatter",
        mode: "lines",
        line: { color: COLOR_SINGLE },
        name: "Curva OC"
      }];

      if (AQL !== null) {
        oc_traces.push({
          x: [AQL, AQL],
          y: [0, 1],
          mode: "lines",
          line: { dash: "dash", color: "orange" },
          name: `AQL: ${AQL.toFixed(4)}`
        });
        oc_traces.push({
          x: [AQL],
          y: [1 - alpha],
          mode: "markers+text",
          marker: { color: "orange", size: 8 },
          text: [`(${AQL.toFixed(4)}, ${(1 - alpha).toFixed(4)})`],
          textposition: "top right",
          textfont: { family: "Aller" },
          name: "AQL marker"
        });
      }
      if (LQL !== null) {
        oc_traces.push({
          x: [LQL, LQL],
          y: [0, 1],
          mode: "lines",
          line: { dash: "dot", color: "purple" },
          name: `LQL: ${LQL.toFixed(4)}`
        });
        oc_traces.push({
          x: [LQL],
          y: [beta],
          mode: "markers+text",
          marker: { color: "purple", size: 8 },
          text: [`(${LQL.toFixed(4)}, ${beta.toFixed(4)})`],
          textposition: "bottom right",
          textfont: { family: "Aller" },
          name: "LQL marker"
        });
      }

      Plotly.newPlot("plot_oc", oc_traces, {
        title: {text: `Curva OC (Pₐ) - ${titleMap[dist]}`, font: { family: "Crimson Pro" }},
        xaxis: { title: "Fracción defectuosa (p)", 
        titlefont: { family: "Aller" },
        tickfont: { family: "Aller" }},
        yaxis: { title: "Probabilidad de aceptación", 
        titlefont: { family: "Aller" },
        tickfont: { family: "Aller" }},
        legend: { font: { family: "Aller" } },
        margin: { t: 40 },
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)'
      });
//AOQ
      Plotly.newPlot("plot_aoq", [{
        x: x,
        y: AOQ_y,
        type: "scatter",
        mode: "lines",
        line: { color: COLOR_SINGLE }
      }], {
        title: { text:`Curva AOQ - ${titleMap[dist]}`, font:{ family:"Crimson Pro" } },
        xaxis:{ title:"Fracción defectuosa (p)", 
        titlefont: { family: "Aller" },
        tickfont: { family: "Aller" }},
        yaxis:{ title:"Average Outgoing Quality", 
        titlefont: { family: "Aller" },
        tickfont: { family: "Aller" }},
        paper_bgcolor:'rgba(0,0,0,0)',
        plot_bgcolor:'rgba(0,0,0,0)',
        margin: { t: 40 }
      });
//ITP
      Plotly.newPlot("plot_itp", [{
        x: x,
        y: ITP_y,
        type: "scatter",
        mode: "lines",
        line: { color: COLOR_SINGLE }
      }], {
        title:{ text:`Curva ITP - ${titleMap[dist]}`, font:{ family:"Crimson Pro" } },
        xaxis:{ title:"Fracción defectuosa (p)", 
        titlefont: { family: "Aller" },
        tickfont: { family: "Aller" }},
        yaxis:{ title:"Índice de Tasa de Producción", 
        titlefont: { family: "Aller" },
        tickfont: { family: "Aller" }},
        paper_bgcolor:'rgba(0,0,0,0)',
        plot_bgcolor:'rgba(0,0,0,0)',
        margin: { t: 40 }
      });
    }
    window.onload = function () {
      renderControls();
      updatePlots();
    };
  </script>

      <footer style="margin-top: 2em; font-size: 0.8em; text-align: center; color: gray;">
      Creado por Steven García Goñi <img src="https://stevenggoni.github.io/images/Cuervos_SinFondo-01.png" width="20" style="vertical-align:middle; margin-right:6px;">· Para la Escuela de Ingeniería Industrial de la Universidad de Costa Rica · Actualizado: Enero 2026
    </footer>
  </div>
</body>

</div>
```

